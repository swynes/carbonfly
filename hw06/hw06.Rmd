---
title: "hw06"
output: html_document
---

```{r setup, cache = F}
knitr::opts_chunk$set(error = TRUE)
#This alters the knit process so that errors can be displayed, which I need for this session where I intentionally introduce errors to test my functions
```

### Practicing functions with a CARBON CALCULATOR

In this homework I'm going to start by trying to make my own function that acts as a carbon calculator (translating two airport codes into a distance and then an amount of greenhouse gases).

Step 1 is to find code that converts latitude and longitude into greater circle distance. This code is long, but is very precise because it accounts for the fact that the earth is not a perfect sphere, which most available calculators neglect. I found it here: https://www.r-bloggers.com/great-circle-distance-calculations-in-r/
```{r}
deg2rad <- function(deg) return(deg*pi/180) #Change degrees into radians
#CHECK
deg2rad(180)

gcd.vif <- function(long1, lat1, long2, lat2) {

# WGS-84 ellipsoid parameters
a <- 6378137         # length of major axis of the ellipsoid (radius at equator)
b <- 6356752.314245  # ength of minor axis of the ellipsoid (radius at the poles)
f <- 1/298.257223563 # flattening of the ellipsoid

L <- long2-long1 # difference in longitude
U1 <- atan((1-f) * tan(lat1)) # reduced latitude
U2 <- atan((1-f) * tan(lat2)) # reduced latitude
sinU1 <- sin(U1)
cosU1 <- cos(U1)
sinU2 <- sin(U2)
cosU2 <- cos(U2)

cosSqAlpha <- NULL
sinSigma <- NULL
cosSigma <- NULL
cos2SigmaM <- NULL
sigma <- NULL

lambda <- L
lambdaP <- 0
iterLimit <- 100
while (abs(lambda-lambdaP) > 1e-12 & iterLimit>0) {
sinLambda <- sin(lambda)
cosLambda <- cos(lambda)
sinSigma <- sqrt( (cosU2*sinLambda) * (cosU2*sinLambda) +
(cosU1*sinU2-sinU1*cosU2*cosLambda) * (cosU1*sinU2-sinU1*cosU2*cosLambda) )
if (sinSigma==0) return(0)  # Co-incident points
cosSigma <- sinU1*sinU2 + cosU1*cosU2*cosLambda
sigma <- atan2(sinSigma, cosSigma)
sinAlpha <- cosU1 * cosU2 * sinLambda / sinSigma
cosSqAlpha <- 1 - sinAlpha*sinAlpha
cos2SigmaM <- cosSigma - 2*sinU1*sinU2/cosSqAlpha
if (is.na(cos2SigmaM)) cos2SigmaM <- 0  # Equatorial line: cosSqAlpha=0
C <- f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha))
lambdaP <- lambda
lambda <- L + (1-C) * f * sinAlpha *
(sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)))
iterLimit <- iterLimit - 1
}
if (iterLimit==0) return(NA)  # formula failed to converge
uSq <- cosSqAlpha * (a*a - b*b) / (b*b)
A <- 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)))
B <- uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)))
deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM^2) -
B/6*cos2SigmaM*(-3+4*sinSigma^2)*(-3+4*cos2SigmaM^2)))
s <- b*A*(sigma-deltaSigma) / 1000

return(s) # Distance in km
}
```



Now I run the code with example coordinates (translated into radians) for the flight between Pearson and Gatwick airport:

```{r}
#Template for GCD
#gcd.vif(long1,lat1,long2,lat2)

#Actual calculation
gcd.vif(-1.389815387,0.762311349,-0.003320978,0.892701983)
```



Now I want a function that will take that distance, and multiply it by a certain amount of emissions according to some if statements. So if the distance is less than 463km it should apply one emissions factor (0.27867kgCO2/km), if it is longer than 463 but shorter than 3700 it should apply a second emissions factor (0.16844kgCO2/km), and if it is longer than or equal to 3700 it should multiply the distance by a third emissions factor(0.19162kgCO2/km). Emissions factors from: (https://www.gov.uk/government/publications/greenhouse-gas-reporting-conversion-factors-2016)
R operators from: https://www.statmethods.net/management/operators.html


```{r}
co2calculator <- function(distance) {
  co2e<- if(distance<=463){
    distance*0.27867
    }   else if (distance>463 && distance<3700) {
    distance*0.16844
  } else if (distance>=3700) {
    distance*0.19162
  } 
  return(co2e)
  }

co2calculator(1) # Check that for a value under 463 0.27867 is the emissions factor
co2calculator(1000) #Check that for a medium range value 0.16844 is the factor
co2calculator(10000) #Check that for a long range value 0.19162 is the factor
```



Now if I nest the function for changing longitude and latitude into radians, inside of the function for getting distance from radians, inside of my carbon calculator, I can get the results by inputting only the longitude and latitude coordinates. Let's call this function carboncalculator and test it.

```{r}
  #note that I have switched  the order of lat and long in this formula because the #function I copied from the internet went against geography conventions
carboncalculator <- function(lat1deg,long1deg,lat2deg,long2deg) {
  co2calculator(
    gcd.vif(
      deg2rad(long1deg),
      deg2rad(lat1deg),
      deg2rad(long2deg),
      deg2rad(lat2deg)))
}

carboncalculator(50,100,50,100)
#This returns an error which is good because the length of the trip is zero

carboncalculator(49.3,123.1,50,119.4)
#This is the trip from Vancouver to Kelowna, and the answer provided is reasonable (77kg of CO2)

carboncalculator(51.2,0.2,22.3,113.9)
#This is the trip from London (Gatwick Airport) to Hong Kong, and the answer provided is reasonable (1844kg of CO2)

carboncalculator(TRUE,TRUE,FALSE,FALSE)
#Amazingly, this gives us an answer, which is a problem. I now need to add some safeguards.

```



Adding stop if statements to my carbon calculator function:

```{r}
carboncalculator2 <- function(lat1deg,long1deg,lat2deg,long2deg) {
    if(!is.numeric(lat1deg)){
      stop('this function only works for numeric input\n',
           'You have provided an object of class:',class(lat1deg)[1])
    }
    co2calculator(
    gcd.vif(
      deg2rad(long1deg),
      deg2rad(lat1deg),
      deg2rad(long2deg),
      deg2rad(lat2deg)))
}

carboncalculator2(1,2,3,4)
#Check that it still works the same way for regular inputs

carboncalculator2(TRUE,TRUE,FALSE,FALSE)
#This gives the appropriate error message, but now I need to add that error message for all longitude and latitude inputs:

carboncalculator3 <- function(lat1deg,long1deg,lat2deg,long2deg) {
    if(!is.numeric(lat1deg)){
      stop('this function only works for numeric input\n',
           'For latitude 1, you have provided an object of class:',class(lat1deg)[1])
    }
   if(!is.numeric(long1deg)){
      stop('this function only works for numeric input\n',
           'For longitude 1, you have provided an object of class:',class(long1deg)[1])
    }
   if(!is.numeric(lat2deg)){
      stop('this function only works for numeric input\n',
           'For latitude 2, you have provided an object of class:',class(lat2deg)[1])
    }
   if(!is.numeric(long2deg)){
      stop('this function only works for numeric input\n',
           'For longitude 2, you have provided an object of class:',class(long2deg)[1])
    }
      co2calculator(
    gcd.vif(
      deg2rad(long1deg),
      deg2rad(lat1deg),
      deg2rad(long2deg),
      deg2rad(lat2deg)))
}

carboncalculator3(1,2,3,4)
#Check to see that it still works on regular inputs

carboncalculator3(1,TRUE,3,4)


```



I now have an error message that tells you EXACTLY which input is of the wrong class and which class it should be! 

The next step for my carbon calculator would be to have it work just by inputting airport codes instead of longitude and latitude. I will have to leave that for my package because this was already too much work!


