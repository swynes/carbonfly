---
title: "hw06"
author: "Wynes"
date: "November 2, 2017"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Homework 6

In this homework I'm going to start by trying to make my own function that acts as a carbon calculator (translating two airport codes into a distance and then an amount of greenhouse gases).

Step 1 is to find code that converts latitude and longitude into greater circle distance. This code is long, but is very precise because it accounts for the fact that the earth is not a perfect sphere, which most available calculators neglect. I found it here:
https://www.r-bloggers.com/great-circle-distance-calculations-in-r/

```{r}
deg2rad <- function(deg) return(deg*pi/180)
gcd.vif <- function(long1, lat1, long2, lat2) {
 
  # WGS-84 ellipsoid parameters
  a <- 6378137         # length of major axis of the ellipsoid (radius at equator)
  b <- 6356752.314245  # ength of minor axis of the ellipsoid (radius at the poles)
  f <- 1/298.257223563 # flattening of the ellipsoid
 
  L <- long2-long1 # difference in longitude
  U1 <- atan((1-f) * tan(lat1)) # reduced latitude
  U2 <- atan((1-f) * tan(lat2)) # reduced latitude
  sinU1 <- sin(U1)
  cosU1 <- cos(U1)
  sinU2 <- sin(U2)
  cosU2 <- cos(U2)
 
  cosSqAlpha <- NULL
  sinSigma <- NULL
  cosSigma <- NULL
  cos2SigmaM <- NULL
  sigma <- NULL
 
  lambda <- L
  lambdaP <- 0
  iterLimit <- 100
  while (abs(lambda-lambdaP) > 1e-12 & iterLimit>0) {
    sinLambda <- sin(lambda)
    cosLambda <- cos(lambda)
    sinSigma <- sqrt( (cosU2*sinLambda) * (cosU2*sinLambda) +
                      (cosU1*sinU2-sinU1*cosU2*cosLambda) * (cosU1*sinU2-sinU1*cosU2*cosLambda) )
    if (sinSigma==0) return(0)  # Co-incident points
    cosSigma <- sinU1*sinU2 + cosU1*cosU2*cosLambda
    sigma <- atan2(sinSigma, cosSigma)
    sinAlpha <- cosU1 * cosU2 * sinLambda / sinSigma
    cosSqAlpha <- 1 - sinAlpha*sinAlpha
    cos2SigmaM <- cosSigma - 2*sinU1*sinU2/cosSqAlpha
    if (is.na(cos2SigmaM)) cos2SigmaM <- 0  # Equatorial line: cosSqAlpha=0
    C <- f/16*cosSqAlpha*(4+f*(4-3*cosSqAlpha))
    lambdaP <- lambda
    lambda <- L + (1-C) * f * sinAlpha *
              (sigma + C*sinSigma*(cos2SigmaM+C*cosSigma*(-1+2*cos2SigmaM*cos2SigmaM)))
    iterLimit <- iterLimit - 1
  }
  if (iterLimit==0) return(NA)  # formula failed to converge
  uSq <- cosSqAlpha * (a*a - b*b) / (b*b)
  A <- 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)))
  B <- uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)))
  deltaSigma = B*sinSigma*(cos2SigmaM+B/4*(cosSigma*(-1+2*cos2SigmaM^2) -
                                      B/6*cos2SigmaM*(-3+4*sinSigma^2)*(-3+4*cos2SigmaM^2)))
  s <- b*A*(sigma-deltaSigma) / 1000
 
  return(s) # Distance in km
}
```



Now I run the code with example coordinates (translated into radians) for the flight between Pearson and Gatwick airport:
```{r}

#Template for GCD
gcd.vif(long1,lat1,long2,lat2)

#Actual calculation
gcd.vif(-1.389815387,0.762311349,-0.003320978,0.892701983)
```



That value is similar to the distance you will get by searching this online, so I trust that the process so far is working. Now I need to add a function that translates degrees (latitude and longitude coordinates) into radians.

```{r}

#create a vector for the coordinates of a flight from YYZ to LGW
yyz_lgw<-c(-79.630556,43.677223,-0.190278,51.148056)
	
#transform coordinates in vector into degrees
yyz_lgw_deg <- deg2rad(yyz_lgw)

gcd.vif(yyz_lgw_deg) #doesn't work because gcd.vif wants four numbers separated by commas
	

```

